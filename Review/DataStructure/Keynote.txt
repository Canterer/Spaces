
KMP算法：字符串匹配算法
	简单算法：两个字符串从头开始匹配,
		从start_main的位置开始,i=start_main,j=0
		i=0,j=0
		while(i<len(mainStr))
		{
			if(mainStr[i] == subStr[j])
			{
				++i,++j;
			}else
			{
				i = i - j;//返回初始位置
				i = i + 1;//主串位置前移
				j = 0;
			}
			if(j == len(subStr))
				return i - j;匹配成功
		}
		return -1;匹配失败
	KMP算法： 每次匹配失败 子串位置 回退至 x 位置继续匹配
		i = 0, j =0;
		while(i<len(mainStr))
		{
			if(mainStr[i] == subStr[j])
			{
				++i,++j;
			}else if( j == 0 )//第一字符失败
			{
				++i;
			}else{
				j = next(j-1);//后退子串位置
			}
		}
	next数组的算法
	原理： 下标为j的字符匹配失败,则主串已匹配的内容是知晓的即subStr[0:j-1]
	如果下一个匹配位置为i=4,则前subStr[0:i-1]不用匹配了
		代表subStr[0:i-1]==subStr[j-i:j-1]
		求最长前缀等于后缀
		前缀[0:i-1]=后缀[j-i:j-1]
		next(j-1)代表从[0:j-1]的字符串最长前缀等于后缀的长度
		next(j-1)=i=4 代表sub[0:i-1]==subStr[j-i:j-1]
		sub[0:i-1-1]==subStr[j-i:j-2]=next(j-2)


	next(j-1)的所有可匹配前缀=后缀, 对next(j-2)的所有可匹配长度都成立
	证明： next(j-1) 代表 subStr[0:i-1]==subStr[j-i:j-1]
		则 subStr[0:i-2]+subStr[i-1] == subStr[j-i:j-2]+subStr[j-1]
	next(j-2) 代表 sub[0:i-2]==subStr[j-i:j-2]

	next(j-1) = next(j-2) + 1 或 next(j-1) < next(j-2)
	如果 subStr[i-1] != subStr[j-1] 则 subStr[0:i-2] 也可能等于 subStr[j-i:j-2]

	结论：每个next(j-1)的匹配实例前缀=后缀, 对于next(j-2)都成立
	next(j-2)成立的匹配实例前缀=后缀  根据subStr[j-1]是否与匹配的前缀字符串 下一个字符是否相等 可判断next(j-1)是否大于next(j-2)

	next(j-2)=x,则最长匹配前缀是subStr[0:x-1],下一个字符是subStr[x]
	若subStr[x]等于subStr[j-1],则next(j-1)=next(j-2)+1
	若不等,则next(j-1)<next(j-2), 进一步缩小了 next(j-1)的取值范围。
	递归处理,则可以逐步缩小 取值

	对于 next(j-3)的最长匹配前缀数 后两个字符如果等于subStr[j-2:j-1]则
		next(j-1) = next(j-3) + 2

		




平衡二叉树、红黑树都需要父指针用来遍历。三指针存储

平衡操作分：左旋、右旋、左右旋、右左旋
二叉树的一个结点上升操作,可以理解为单次左旋或右旋
结点上升：自己上升父节点下降
	若自身是左孩子,则父结点大于自身,所以父节点下降操作只能作为自己的右孩子。同时自己的右孩子做为父节点的左孩子
	若自身是右孩子,则父节点小于自身,所以父节点下降操作只能作为自己的左孩子。同时自己的左孩子作为父节点的右孩子
	自身替代父结点,维持连接的原指针(左指针或右指针)

左右旋或右左旋的情况:  自己上升两次
	即父节点 < 自己 < 祖父结点  或者 祖父结点 < 自己 < 父结点
	最终调整为 处中间的自己 上升只顶端  父节点、祖父结点 视两者大小作为 左右子节点

平衡的最终状态就是 三个结点 处于 左 上 右 即三个值处于中间的处于上
	为此四种平衡操作：看自身、父节点、祖父结点 谁是中间值。
	若父节点是中间值 即只需父节点 一次 上升操作即左旋或右旋。
	若自身是中间值 则需要两次上升操作 即左右旋或右左旋。


红黑树：
	结点是红或黑
	根结点是黑、叶子结点(空结点)是黑
	红色结点的两个子结点是黑
	从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。

	路径上不存在两个连续的红色结点。所以最短路径是全黑色的，最长路径是红黑相间的。 由于结点到叶子路径具有相同数目的黑色结点。所以没有路径的长度是最短路径的两倍。

	新插入的结点都是红色,若父节点是红色,则向上调整。调整的结点为父节点
	待调整的结点是红色,则父结点必为黑且存在。分两者情况：
	第一种：兄弟存在且为红色(上黑下两红)。调整为上红下两黑。
	第二种：无兄弟或兄弟为黑(上黑下一红一黑)。调整为上红自己黑即下两黑。继续向上调整。

	第一种上黑下两红 无需旋转只变色
	第二种上黑下一红一黑   先旋转再变色

	这里是不平衡的状态，只修改颜色。满足红黑树性质。
	根据待调整结点(颜色由黑变红)、父结点(红色,为黑则不需要调整)、祖父结点


B-树、B+树、B*树
	B-树是一颗m阶的平衡树，通常应用于文件索引系统的实现
	条件：
		树中每个结点最多含有m个孩子
		除根结点和叶子结点(NULL结点)之外，其它每个节点至少ceil(m/2)个孩子，ceil向上取整。
		除根节点之外的节点关键字个数n 满足 ceil(m/2-1) <= n <= m-1


m阶平衡树：一个节点有m个地址域,m-1个数据域
AVL树：二阶平衡树。一个节点有2个地址域,1个数据域。同时要求左右孩子的高度差不超过1

B-树: 
	根节点的数据由于新增，导致数量为m个，则取中间值留着，将其分裂成两个子节点
	子节点的数据新增,则分裂成两个节点，给父节点插入数据。

	每次新增在最底层节点插入数据, 该节点数据域=m,则留中间关键字,分裂成两个节点。
	中间关键字，插入父节点指定位置。父节点满则递归分裂并向上插入数据


	删除：分两种情况
		第一种,删除 非叶子节点的关键字。即存在左右孩子,寻找孩子中最小数或最大数,替换自己。从而转换成仅删除 叶子节点的关键字
		第二种,删除 叶子节点的关键字
			若数据满足大于最少关键字数,直接删除无影响
			若数据刚好等于最少关键字数,则先删除数据,
				若左右兄弟(仅两个)存在富裕的关键字
					父节点关键字下移补充自身,兄弟结点富裕的关键字替换下移的关键字
				若左右兄弟都仅最少关键字数据,则下移父节点关键字来连接两个兄弟。此时需要递归判断 移除父节点关键字 情况
		注意: 一般仅从左右兄弟结点借关键字。
		从更远的兄弟借数据,则需要中间的每个兄弟 先接受父节点下移关键字作为自身的最大或最小值，然后上交最小值(可能从孩子中取)。
		这里若不是叶子结点,插入最大或最小关键字，还得从孩子取最小值或最大值作为替换。

B+树：B树的变种
	每个结点只存索引,然后将结点压平,组成一个链表。链表中的结点才存真实的数据。
	每次分裂等于新增一个链表结点,合并等于合并两个链表结点。
	借数据等于从链表中转移数据到另一个链表。

	建议从链表构建开始(指定根结点代表的链表),然后按中序遍历来

	错误，不能简单理解压平。三个孩子，怎么压平？
	应该是树的链表表示法: 错误


	非叶子结点只有关键字索引,不存放数据。叶子结点携带数据。
	每个叶子结点 存放着一个特殊的关键字(最小值)即存放着父节点的关键字。不计算在关键字数量中
	叶子结点 通过指针链接成 链表。可以方便的遍历结点。便于区间查找。



		

线性表：
	顺序存储：数组
	链式存储：单链表、循环链表、双链表
限定性线性表：	栈与队列
	
串：
	KMP匹配算法
	定长顺序串
		typedef struct{
			int len;
			char ch[MAX];
		}SString;
	堆串
		typedef struct{
			int len;
			char *ch;
		}HString;
		所有串名构建符号表   符号名+len+开始位置
	块链串
		typedef struct Block{
			char ch[4];
			struct Block *next; 
		}Block;
		typedef struct{
			int len;
			Block *head,*tail;
		}BLString

广义表： n个数据元素的有限序列,数据元素即可以是单个元素，也可以是广义表
	头尾链表存储结构
		表结点： tag=1、hp、tp
		原子结点： tag=0、atom
		typedef enum { ATOM, LIST } ElemTag;
		typedef struct GLNode{
			ElemTag tag;
			union{
				AtomType atom;
				struct {
					struct GLNode *hp,*tp;
				} htp;
			}
		}GLNode, *GList;
	同层结点链存储结构
		表结点： tag=1、hp、tp
		原子结点： tag=0、atom、tp
		typedef enum { ATOM, LIST } ElemTag;
		typedef struct GLNode{
			ElemTag tag;
			struct GLNode *tp;
			union{
				AtomType atom;
				struct GLNode *hp;
			}
		}GLNode, *GList;

二叉树：
	前序、后序、中序遍历
	中序加前(或后)序 重建二叉树
	线索二叉树
		LChild、LTag、Data、RTag、RChild
		LTag为1代表LChild是遍历前驱
		RTag为1代表RChild是遍历后驱
		算法思想：
			通过Pre保存前一个访问的结点
			若当前结点无LChild,则设置Pre为遍历前驱
			若Pre结点无RChild,则设置Pre的遍历后驱为当前结点
	哈夫曼树、哈夫曼编码
		每次合并两个结点、产生一个新结点。即每合并一次减少一个结点,直到存在一个结点时不操作。即合并N-1次产生N-1个新节点
		#define N 20 叶子结点数
		#deifen M 2*N-1  所有结点数
		typedef struct{
			int weight;
			int parentIndex;
			int LChildIndex;
			int RChildIndex;
		}HTNode, HuffmanTree[M+1];//0号不放结点

树、森林
	双亲表示法：
		Data、ParentIndex
		采用数组保存所有结点
	孩子表示法：
		数据结点：Data、FirstChildPtr
		孩子结点：ChildIndex、NextChildPtr
	孩子兄弟表示法：
		typedef struct CSNode{
			DataType data;
			struct CSNode *FirstChild;第一个孩子
			struct CSNode *NextSibling;下一个兄弟
		}CSNode, *CSTree;
	先根遍历：先访问根结点、从左到右访问每一个子树
	后根遍历：先从左到右访问每一个子树，再访问根结点
		树的先根遍历  等同于 转换后二叉树的前序遍历
		树的后根遍历  等同于 转换后二叉树的中序遍历
	先根遍历  根结点+左子树 第一个子树  右子树代表第一个兄弟  前序遍历
	后跟遍历  左子树+根结点 第一个子树  右子树代表第一个兄弟  中序遍历


并查集与等价类划分
	树的双钱表示法
	Init(SS, S)//S有n个元素组成, 构建n个单元素集合。
	Find(SS, x)//查找x所在的集合S
	SS代表森林 S代表树 所有集合与单个集合

图：
	邻接矩阵表示法
	邻接表表示法
	十字链表
	邻接多重表

	有向无环图的应用
		AOV-网(Activity On Vertex Network)：顶点表示活动、有向弧表示活动优先级
			拓扑排序：
				找一个无前驱的结点输出,删除该结点和以它为起点的边。重复该操作即可得到拓扑排序
		AOE-网(Activity On Edeg Network)：顶点表示事件、弧表示活动、弧的权重代表活动时间
			关键路径：
				入度为0的点称为源点、出度为0的点成汇点。

	最小生成树：
		加点法：普里姆算法
			按权重从小到大选择边,满足两个顶点在两个集合中。
			数组closeedge[]记录从U到V-U具有最小代价的边。
			每次新加一个结点,刷新closeedge数组			
		加边法：克鲁斯卡尔算法
			按权重从小到大选择边,满足两个顶点不在一个集合。
	求某一点到其他点的最短路径：
		加点法：迪杰斯特拉(Dijkstra)
			查找最短弧,满足顶点分别在两端集合。逐渐添加点
			顶点分两组： 已求出最短路径的、未求出最短路径的
			辅助数据dist 目前找到的 从V0到终点Vi的最短路径
			从dist中找最小的值且结点未属于(已求出最短路径的结点集合)
			更新dist数组,并重复
	求任意两点间的最短路径：弗洛伊德算法
		动态规划
			求任意两点间的最短路径 不包含序号大于i的结点


插入排序：
	直接插入排序： 稳定  O(n) ~ O(n^2)
	折半插入排序： 稳定  O(nlogn)  ~ O(n^2)
	希尔排序:	  不稳定	  O(n^1.5)
		delta 为数组的一半  每次递减为一半

	for(int i = start+delta; i < end; ++i)
	{
		for(int j = i; i > start; j = j - delta)
		{
			if(v[j] < v[j-delta])
				swap(v[j],v[j-delta])
		}
	}
	类似插入排序。适合规模中等数据

交换类排序：
	冒泡排序： 稳定	
	快速排序： 不稳定
		基于分治法，选择一个值作为中间值 分裂成两个小序列
		选定一个中间值(多重方式)  然后与第一个元素交换
		i = 0 当前i为插入位置  从后往前找即j递减 逆序元素 插入到i的位置
		新的插入位置为j  然后i递增从前往后找  插入到j的位置  新的插入位置为i

选择类排序：
	简单选择排序：	不稳定  第一个元素可能被替换到最后了
	树性选择排序： 锦标赛排序	稳定
	堆排：	不稳定  nlog2(n)
合并类排序：
	归并排序
分配类排序：
	多关键字排序： 扑克牌
	链式基数排序： 低位优先排序  

最常用的外部排序是归并排序
	分多块排序后， 然后建立缓冲池(两输入一输出) 合并排序。